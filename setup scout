// Â© jmosullivan
//@version=5
indicator("Setup Scout", max_lines_count=500, overlay=true, max_bars_back = 500)

import jmosullivan/PrivateTable/7
import jmosullivan/Utilities/12

lookback        = input.int(5, "Lookback Value")
bullishColor    = input.color(defval=color.rgb(40, 98, 255),  title="Bullish/Bearish Color", inline="1")
bearishColor    = input.color(defval=color.rgb(235, 46, 175), title="", inline="1")

var timeframeArray = array.from("5", "15", "60", "240", "D", "W", "M")
var timeframeMinutesArray = array.from(5, 15, 60, 240, 1440, 7200, 44640)
var timeframeEnglishArray = array.from("5m", "15m", "1h", "4h", "Daily", "Weekly", "Monthly")

var pivot5mMatrix = matrix.new<float>()
var pivot15mMatrix = matrix.new<float>()
var pivot1hMatrix = matrix.new<float>()
var pivot4hMatrix = matrix.new<float>()
var pivot1dMatrix = matrix.new<float>()
var pivot1wMatrix = matrix.new<float>()
var pivot1MMatrix = matrix.new<float>()

var labelArray = array.new<label>()
var lineArray = array.new<line>()
var linefillArray = array.new<linefill>()

// Functions

cleanup() =>
    labelCount = array.size(labelArray)
    if (labelCount > 0)
        for i = 0 to labelCount - 1
            label.delete(array.get(labelArray, i))
    
    linefillCount = array.size(linefillArray)
    if (linefillCount > 0)
        for i = 0 to linefillCount - 1
            linefill.delete(array.get(linefillArray, i))

    lineCount = array.size(lineArray)
    if (lineCount > 0)
        for i = 0 to lineCount - 1
            line.delete(array.get(lineArray, i))

getTimeframeEnglish(timeframe) =>
    ix = array.indexof(timeframeArray, timeframe)
    ix > -1 ? array.get(timeframeEnglishArray, ix) : timeframe

getTimeframeMinutes(timeframe, int default = na) =>
    ix = array.indexof(timeframeArray, timeframe)
    ix > -1 ? array.get(timeframeMinutesArray, ix) : default

getTimeframeMultiplier(timeframe) =>
    num = str.tonumber(timeframe)
    if (na(num))
        num := 1
    num

getMatrixByTimeframe(tf) =>
    switch tf
        "5" => pivot5mMatrix
        "15" => pivot15mMatrix
        "60" => pivot1hMatrix
        "240" => pivot4hMatrix
        "D" => pivot1dMatrix
        "W" => pivot1wMatrix
        "M" => pivot1MMatrix
        => matrix.new<float>()

taGetPivotRange(look) =>
    left = look
    right = look
    // barsRemaining = last_bar_index - bar_index
    // if barsRemaining < 3
    //     barsRemaining := 3
    // right := barsRemaining > look ? look : barsRemaining
    [left, right]

taPivotHigh(look) =>
    [left, right] = taGetPivotRange(look)
    ta.pivothigh(left, right)

taPivotLow(look) =>
    [left, right] = taGetPivotRange(look)
    ta.pivotlow(left, right)

drawLabel(_offset, _pivot, _style, _bgcolor) =>
    if not na(_pivot)
        label.new(bar_index[_offset], _pivot, str.tostring(_pivot, format.mintick), style=_style, color=_bgcolor, textcolor=color.white)

trendToNumber(trendString) =>
    switch trendString
        "Up" => 1
        "Down" => 2
        "Megaphone" => 3
        "Consolidating" => 4
        => -1

trendToString(trend) =>
    switch trend
        1 => "Up"
        2 => "Down"
        3 => "Megaphone"
        4 => "Consolidating"
        => "Unknown"

trendToColor(trend) =>
    switch trend
        1 => color.green
        2 => color.red
        3 => color.gray
        4 => color.fuchsia
        => color.black

getLabelColor(trend) =>
    switch trend
        1 => color.green
        2 => color.red
        3 => color.blue
        4 => color.orange
        => color.black

getColumnIndex(columnName) =>
    int ix = switch columnName
        "pivotPrice" => 0       // The price level (float)
        "pivotTime" => 1        // The time of the bar
        "pivotType" => 2        // The pivot type: high (1) or low (0)
        "isHigher" => 3         // isHigher (1) or isLower (0) (this and PivotType make "Higher High", "Lower High", etc)
        "priceDistance" => 4    // priceDistance: the full price-distance of the move from the previous level to this level
        "distanceMA" => 5       // 20period moving average of priceDistance for this pivot type (high or low)
        "percentInRange" => 6   // Percent this move is in the prior range (the fib level pull)
        "trend" => 7            // The current Trend
        "trendCount" => 8       // The count of the # of times that this trend has happened consecutively
        => -1
    ix

matrixGet(matrix, row, columnName) =>
    matrix.get(matrix, row, getColumnIndex(columnName))

matrixSet(matrix, row, columnName, value) =>
    matrix.set(matrix, row, getColumnIndex(columnName), value)

getDistanceMa(matrix, pivotType, length = 20) =>
    ma = float(na)
    sum = float(0)
    count = int(0)
    matrixRows = matrix.rows(matrix)
    start = matrixRows - length * 2
    if (start >= 0)
        for i = start to matrixRows - 1
            if matrixGet(matrix, i, "pivotType") == pivotType
                sum += matrixGet(matrix, i, "priceDistance")
                count += 1
    
        ma := sum / count
    ma

getTrend(pivotMatrix, startIndex = -1) =>
    trend = trendToNumber("Unknown")
    isHigher = 0 // Lower
    pivotRows = matrix.rows(pivotMatrix)
    _startIndex = startIndex == -1 ? pivotRows-1 : startIndex
    if (_startIndex > 3)
        pivot1Type = matrixGet(pivotMatrix, _startIndex, "pivotType")
        pivot1 = matrixGet(pivotMatrix, _startIndex, "pivotPrice")
        pivot2 = matrixGet(pivotMatrix, _startIndex-1, "pivotPrice")
        pivot3 = matrixGet(pivotMatrix, _startIndex-2, "pivotPrice")
        pivot4 = matrixGet(pivotMatrix, _startIndex-3, "pivotPrice")

        isHigher := pivot1 > pivot3 ? 1 : 0
        isHigherLow = bool(na)
        isHigherHigh = bool(na)
        // If pivot1 is a high...
        if (pivot1Type == 1)
            isHigherLow := pivot2 > pivot4
            isHigherHigh := pivot1 > pivot3
        else
            isHigherLow := pivot1 > pivot3
            isHigherHigh := pivot2 > pivot4

        if isHigherLow and isHigherHigh
            trend := trendToNumber("Up")
        else if not isHigherLow and not isHigherHigh
            trend := trendToNumber("Down")
        else if not isHigherLow and isHigherHigh
            trend := trendToNumber("Megaphone")
        else if isHigherLow and not isHigherHigh
            trend := trendToNumber("Consolidating")
    [isHigher, trend]

// Loop through a collection of trends (smaller timeframes last) looking for bullish or bearish trend. If not up or down, use parent's trend.
// Returns -1 if bullish or bearish could not be determined.
getBullish(trendArray) =>
    isBullish = -1
    t = int(na)
    trendCount = array.size(trendArray)
    while isBullish == -1 and trendCount > 0
        trendCount -= 1
        t := array.get(trendArray, trendCount)
        if t == 1
            isBullish := 1
        else if t == 2
            isBullish := 0

    isBullish

processPivotDetail(pivotMatrix, pivotIndex) =>
    // pivotMatrix columns: 
    // 0: The price level (float)
    // 1: The time of the bar
    // 2: The pivot type: high (1) or low (0)
    // 3: is Higher (1) or isLower (0) 
    // 4: priceDistance: the full price-distance of the move from the previous level to this level
    // 5: 20period moving average of priceDistance for this pivot type (high or low)
    // 6: Percent this move is in the prior range (the fib level pull)
    // 7: The current Trend
    // 8: The count of the # of times that this trend has happened consecutively
    matrixRows = matrix.rows(pivotMatrix)
    pivot = matrixGet(pivotMatrix, pivotIndex, "pivotPrice")
    pivotType = matrixGet(pivotMatrix, pivotIndex, "pivotType")
    priceDistance = float(na)
    percentInRange = float(na)
    // If there is at least one other pivot recorded, begin saving additional data
    if (matrixRows > 1)
        pivot2 = matrixGet(pivotMatrix, matrixRows-2, "pivotPrice")
        priceDistance := math.abs(pivot - pivot2)
        matrixSet(pivotMatrix, matrixRows-1, "priceDistance", priceDistance) // 4: priceDistance: the full price-distance of the move from the previous level to this level
    if (matrixRows > 40)
        matrixSet(pivotMatrix, matrixRows-1, "distanceMA", getDistanceMa(pivotMatrix, pivotType)) // 5: 20period moving average of priceDistance for this pivot type (high or low)
    if (matrixRows > 2)
        lastPriceDistance = matrixGet(pivotMatrix, matrixRows-2, "priceDistance")
        percentInRange := priceDistance * 100 / lastPriceDistance
        matrixSet(pivotMatrix, matrixRows-1, "percentInRange", percentInRange) // 6: Percent this move is in the prior range (the fib level pull)
    if (matrixRows > 3)
        [isHigher, trend] = getTrend(pivotMatrix)
        matrixSet(pivotMatrix, matrixRows-1, "trend", trend) // 7: The current Trend
        lastTrend = matrixGet(pivotMatrix, matrixRows-2, "trend")
        lastTrendCount = matrixGet(pivotMatrix, matrixRows-2, "trendCount")
        trendCount = trend == lastTrend ? lastTrendCount + 1 : 0
        matrixSet(pivotMatrix, matrixRows-1, "trendCount", trendCount) // 8: The count of the # of times that this trend has happened consecutively
        matrixSet(pivotMatrix, matrixRows-1, "isHigher", isHigher)

getLookbackSpan(timeframe) =>
    if (timeframe.isminutes)
        currentTimeframeMinutes = str.tonumber(timeframe.period)

getCorrectPivotTime(pivot, pivotType, lookDistance, timeframe) =>
    matchIndex = int(na)
    // timeframe of the pivot divided by the currently viewed timeframe multiplied by twice the lookback (left and right combined)

    currentTimeframeMinutes = getTimeframeMinutes(timeframe.period)
    examinedTimeframeMinutes = getTimeframeMinutes(timeframe)
    if not na(currentTimeframeMinutes) and not na(examinedTimeframeMinutes)
        max = (examinedTimeframeMinutes / currentTimeframeMinutes) * (lookDistance * 2)
        i = 0
        source = pivotType == "High" ? high : low
        while na(matchIndex) and i <= max
            if source[i] == pivot
                matchIndex := i
            i += 1
	
    time[na(matchIndex) ? 0 : matchIndex]

// Pivots from request.security don't have accurate times. This looks through the current chart's matrix for the correct time for that pivot
matrixGetPivotTime(matrix, row, timeframe) =>
    matchTime = float(na)
    sourcePivotTime = matrixGet(matrix, row, 'pivotTime')
    if timeframe.period != timeframe
        sourcePivotPrice = matrixGet(matrix, row, 'pivotPrice')
        sourcePivotType = matrixGet(matrix, row, 'pivotType')
        targetMatrix = getMatrixByTimeframe(timeframe.period)
        targetPivotRows = matrix.rows(targetMatrix)
        i = targetPivotRows - 1
        while i > 0 and na(matchTime)
            targetPivotPrice = matrixGet(targetMatrix, i, 'pivotPrice')
            targetPivotTime = matrixGet(targetMatrix, i, 'pivotTime')
            targetPivotType = matrixGet(targetMatrix, i, 'pivotType')
            if (targetPivotType == sourcePivotType and targetPivotPrice == sourcePivotPrice)
                matchTime := targetPivotTime

            i -= 1
	
    na(matchTime) ? sourcePivotTime : matchTime

processPivot(pivotMatrix, pivot, pivotType, lookDistance, timeframe, maxRows = 50) =>
    matrixRows = matrix.rows(pivotMatrix)
    if not na(pivot) // and matrixRows < 100
        [left, right] = taGetPivotRange(lookDistance)
        lastPivot = matrixRows > 0 ? matrixGet(pivotMatrix, matrixRows - 1, "pivotPrice") : float(na)
        lastPivot2 = matrixRows > 1 ? matrixGet(pivotMatrix, matrixRows - 2, "pivotPrice") : float(na)
        lastPivotOfTypeMatches = pivot == nz(lastPivot2)
        lastPivotTypeWasFloat = matrixRows > 0 ? matrixGet(pivotMatrix, matrixRows - 1, "pivotType") : float(na)
        lastPivotTypeWas = na(lastPivotTypeWasFloat) ? string(na) : lastPivotTypeWasFloat == 1 ? "High" : "Low"
        // If the last pivot was the same type as the current one, update the pivot
        if (lastPivotTypeWas == pivotType)
            // If the last pivot was a high and this one is also high, use the higher one
            // OR if the last pivot was a low and this one is also a low, use the lower one
            // Disregard the pivot otherwise
            if (lastPivotTypeWas == "High" and pivot > lastPivot) or (lastPivotTypeWas == "Low" and pivot < lastPivot)
                pivotTime = time[right] // getCorrectPivotTime(pivot, pivotType, lookDistance, timeframe)
                matrixSet(pivotMatrix, matrixRows - 1, "pivotPrice", pivot)
                matrixSet(pivotMatrix, matrixRows - 1, "pivotTime", pivotTime)
                processPivotDetail(pivotMatrix, matrixRows - 1)
        else if not lastPivotOfTypeMatches
            // pivotMatrix will contain the following columns: 
            // 0: The price level (float)
            // 1: The time of the bar
            // 2: The pivot type: high (1) or low (0)
            // 3: is Higher (1) or isLower (0) 
            // 4: priceDistance: the full price-distance of the move from the previous level to this level
            // 5: 20period moving average of priceDistance for this pivot type (high or low)
            // 6: Percent this move is in the prior range (the fib level pull)
            // 7: The current Trend
            // 8: The count of the # of times that this trend has happened consecutively
            matrix.add_row(pivotMatrix, matrixRows, 
              array.from(
               pivot, // 0: The price level (float)
               time[right], // getCorrectPivotTime(pivot, pivotType, lookDistance, timeframe),
               pivotType == "High" ? 1 : 0, // 2: The pivot type: high (1) or low (0)
               float(na), // 3: isHigher (1) or isLower (0)
               float(na), // 4: priceDistance: the full price-distance of the move from the previous level to this level
               float(na), // 5: 20period moving average of priceDistance for this pivot type (high or low)
               float(na), // 6: Percent this move is in the prior range (the fib level pull)
               float(na), // 7: The current Trend
               0 // 8: The count of the # of times that this trend has happened consecutively
              ))

            // Don't let there be more than maxRows pivots per table (memory hog)
            if matrixRows + 1 > maxRows
                matrix.remove_row(pivotMatrix, 0)
                matrixRows -= 1

            processPivotDetail(pivotMatrix, matrixRows)

correctPivotTimes(pivotMatrix) =>
    matrixRows = matrix.rows(pivotMatrix)
    if (matrixRows > 0)
        pivotPrice = matrixGet(pivotMatrix, matrixRows-1, "pivotPrice")
        pivotType = matrixGet(pivotMatrix, matrixRows-1, "pivotType")
        correctPivotTime = int(na)
        i = 0
        while i < 50 and not na(correctPivotTime)
            i += 1
            comparisonValue = pivotType == 1 ? high[i] : low[i]
            if (comparisonValue == pivotPrice)
                correctPivotTime := time[i]
        
        if not na(correctPivotTime)
            matrixSet(pivotMatrix, matrixRows-1, 'pivotTime', correctPivotTime)

requestSecurity(timeframe, expression) =>
    request.security(syminfo.tickerid, timeframe, expression)

definePivotsByTimeframe(timeframe) =>
    // For larger timeframes, save fewer pivots
    // This is done so that smaller timeframe pivots drawn on the chart will fill up the larger ones
    maxRows = 400
    tfIndex = array.indexof(timeframeArray, timeframe)
    maxRows := maxRows / (tfIndex+1)
    lookbackBars = lookback // 10 // Look back the equivalent of 3 bars on the requested timeframe
    pivotMatrix = getMatrixByTimeframe(timeframe)
    pivotHigh = float(na)
    pivotLow = float(na)

    if (timeframe == "5")
        pivotHigh := requestSecurity("5", taPivotHigh(lookbackBars))
        pivotLow := requestSecurity("5", taPivotLow(lookbackBars))
    if (timeframe == "15")
        pivotHigh := requestSecurity("15", taPivotHigh(lookbackBars))
        pivotLow := requestSecurity("15", taPivotLow(lookbackBars))
    if (timeframe == "60")
        pivotHigh := requestSecurity("60", taPivotHigh(lookbackBars))
        pivotLow := requestSecurity("60", taPivotLow(lookbackBars))
    if (timeframe == "240")
        pivotHigh := requestSecurity("240", taPivotHigh(lookbackBars))
        pivotLow := requestSecurity("240", taPivotLow(lookbackBars))
    if (timeframe == "D")
        pivotHigh := requestSecurity("D", taPivotHigh(lookbackBars))
        pivotLow := requestSecurity("D", taPivotLow(lookbackBars))
    if (timeframe == "W")
        pivotHigh := requestSecurity("W", taPivotHigh(lookbackBars))
        pivotLow := requestSecurity("W", taPivotLow(lookbackBars))
    if (timeframe == "M")
        pivotHigh := requestSecurity("M", taPivotHigh(lookbackBars))
        pivotLow := requestSecurity("M", taPivotLow(lookbackBars))

    // else if not na(str.tonumber(timeframe))
    //     // barLook5m = 3
    //     // barLook15m = 9 // 3 5m bars * 3 (because 15/5=3)
    //     // barLook60m = 36 // 3 5m bars * 12 (because 60/5=12)
    //     // barLook240m = 144 // 3 5m bars * 48 (because 240/5=48)
    //     requestedMultiplier = getTimeframeMultiplier(timeframe)
    //     lookbackBars := lookbackBars * math.round(requestedMultiplier / timeframe.multiplier)
    //     // barsRemaining = last_bar_index - bar_index
    //     pivotHigh := taPivotHigh(lookbackBars)
    //     pivotLow := taPivotLow(lookbackBars)

    processPivot(pivotMatrix, pivotHigh, "High", lookbackBars, timeframe, maxRows=maxRows)
    processPivot(pivotMatrix, pivotLow, "Low", lookbackBars, timeframe, maxRows=maxRows)

drawPivotLines(timeframe, color, style=line.style_solid, width=1, maxLines = 26) =>
    if (barstate.islast)
        pivotMatrix = getMatrixByTimeframe(timeframe)
        pivotRows = matrix.rows(pivotMatrix)
        if (pivotRows > 2)
            lastPivotPrice = float(na)
            lastPivotTime = float(na)
            lastPivotType = float(na)
            pivotPrice = float(na)
            pivotTime = float(na)
            pivotType = float(na)
            i = pivotRows - 1
            lineCount = 0
            while i > 0 and lineCount <= maxLines
                // Define the values for drawing
                lastPivotPrice := matrixGet(pivotMatrix, i-1, "pivotPrice")
                lastPivotTime := matrixGetPivotTime(pivotMatrix, i-1, timeframe)
                lastPivotType := matrixGet(pivotMatrix, i-1, "pivotType")
                pivotPrice := matrixGet(pivotMatrix, i, "pivotPrice")
                pivotTime := matrixGetPivotTime(pivotMatrix, i, timeframe)
                pivotType := matrixGet(pivotMatrix, i, "pivotType")

                array.push(lineArray, line.new(
                   xloc=xloc.bar_time,
                   x1=math.round(lastPivotTime), 
                   y1=lastPivotPrice, 
                   x2=math.round(pivotTime),
                   y2=pivotPrice, 
                   color=color,
                   style=style, 
                   width=width
                   ))
                i -= 1
                lineCount += 1

drawPivotAreas(timeframe, color, style=line.style_solid, width=1, maxAreas = 12) =>
    if (barstate.islast)
        pivotMatrix = getMatrixByTimeframe(timeframe)
        pivotRows = matrix.rows(pivotMatrix)
        if (pivotRows > 3)
            areaCount = 0
            pivot1 = float(na)
            pivot2 = float(na)
            pivot3 = float(na)
            pivot4 = float(na)
            pivotTime1 = float(na)
            pivotTime2 = float(na)
            pivotTime3 = float(na)
            pivotTime4 = float(na)
            i = pivotRows - 1
            while i > 3 and areaCount <= maxAreas
                // Define the values for drawing
                pivotIndex = getColumnIndex("pivotPrice")
                pivotTypeIndex = getColumnIndex("pivotType")
                pivot1 := matrix.get(pivotMatrix, i, pivotIndex)
                pivot2 := matrix.get(pivotMatrix, i-1, pivotIndex)
                pivot3 := matrix.get(pivotMatrix, i-2, pivotIndex)
                pivot4 := matrix.get(pivotMatrix, i-3, pivotIndex)
                pivotTime1 := matrixGetPivotTime(pivotMatrix, i, timeframe)
                pivotTime2 := matrixGetPivotTime(pivotMatrix, i-1, timeframe)
                pivotTime3 := matrixGetPivotTime(pivotMatrix, i-2, timeframe)
                pivotTime4 := matrixGetPivotTime(pivotMatrix, i-3, timeframe)

                i := i - 2

                line1 = line.new(
                  xloc=xloc.bar_time,
                  x1=math.round(pivotTime1), 
                  y1=pivot1, 
                  x2=math.round(pivotTime3),
                  y2=pivot3, 
                  color=color,
                  style=style, 
                  width=width
                  )
                line2 = line.new(
                  xloc=xloc.bar_time,
                  x1=math.round(pivotTime2), 
                  y1=pivot2, 
                  x2=math.round(pivotTime4),
                  y2=pivot4, 
                  color=color,
                  style=style, 
                  width=width
                  )
                fillColor = color.new(color, 80)
                array.push(linefillArray, linefill.new(line1, line2, fillColor))
                array.push(lineArray, line1)
                array.push(lineArray, line2)
                areaCount += 1

drawPivotLabel(timeframe, pivotMatrix, rowIndex = 0) =>
    pivotPrice = matrixGet(pivotMatrix, rowIndex, "pivotPrice")
    pivotTime = matrixGetPivotTime(pivotMatrix, rowIndex, timeframe)
    pivotType = matrixGet(pivotMatrix, rowIndex, "pivotType")
    priceDistance = matrixGet(pivotMatrix, rowIndex, "priceDistance")
    distanceMA = matrixGet(pivotMatrix, rowIndex, "distanceMA")
    moveStrength = (priceDistance * 100) / distanceMA
    isHigher = matrixGet(pivotMatrix, rowIndex, "isHigher")
    trend = matrixGet(pivotMatrix, rowIndex, "trend")
    trendCount = matrixGet(pivotMatrix, rowIndex, "trendCount")
    percentInRange = matrixGet(pivotMatrix, rowIndex, "percentInRange")
    textColor = color.white
    labelText = getTimeframeEnglish(timeframe)
       + (isHigher ? " Higher " : " Lower ") + (pivotType == 1 ? "High" : "Low") + " ("
       + str.tostring(pivotPrice, format.mintick) + ")\n"
       + trendToString(trend) + " " + (trendCount > 0 ? str.tostring(trendCount+1) : "") + "\n"
       + "% in Range: " + str.tostring(percentInRange, format.percent) + "\n"
       + "Move: " + str.tostring(distanceMA, format.mintick) 
       + "/" + str.tostring(priceDistance, format.mintick) 
       + " (" + str.tostring(moveStrength, format.percent) + ")"

    pivotLabel = label.new(
       x=math.round(pivotTime),
       y=pivotPrice,
       text=labelText,
       size=size.small,
       xloc=xloc.bar_time,
       color=getLabelColor(trend),
       textcolor=textColor,
       textalign=text.align_left,
       style=(pivotType == 1 ? label.style_label_lower_left : label.style_label_upper_left)
       )
    array.push(labelArray, pivotLabel)

drawPivotLabels(timeframe, maxLabels = 10) =>
    if (barstate.islast)
        pivotMatrix = getMatrixByTimeframe(timeframe)
        pivotRows = matrix.rows(pivotMatrix)
        if (pivotRows > 0)
            start = pivotRows - 1
            end = start - maxLabels
            if (end < 0)
                end := 0
            for i = start to end
                drawPivotLabel(timeframe, pivotMatrix, i)

drawFinalLabel(timeframe) =>
    if (barstate.islast)
        pivotMatrix = getMatrixByTimeframe(timeframe)
        pivotRows = matrix.rows(pivotMatrix)
        if (pivotRows > 0)
            drawPivotLabel(timeframe, pivotMatrix, pivotRows-1)

drawSummaryTable() => 
    if (barstate.islast)
        dataMatrix = matrix.new<string>()
        columnArray = array.from(
           "Timeframe",
           "Trend",
           "#",
           "Set a",
           "at",
           "Scouting",
           "Avg Move",
           "Last",
           "%",
           "Fib %",
           "Curr",
           "%",
           "Fib %"
           )
        matrix.add_row(dataMatrix, 0, columnArray)

        colorMatrix = matrix.new<color>()
        columnCount = array.size(columnArray)
        matrix.add_row(colorMatrix, 0, array.new_color(columnCount, color.blue))

        // Loop through each matrix transferring the last (most recent) row to a table
        for i = array.size(timeframeArray) - 1 to 0
            timeframe = array.get(timeframeArray, i)
            pivotMatrix = getMatrixByTimeframe(timeframe)
            pivotRows = matrix.rows(pivotMatrix)
            if (pivotRows > 0)

                pivotPrice = matrixGet(pivotMatrix, pivotRows-1, "pivotPrice")
                pivotType = matrixGet(pivotMatrix, pivotRows-1, "pivotType")
                isHigher = matrixGet(pivotMatrix, pivotRows-1, "isHigher")
                lastPriceDistance = matrixGet(pivotMatrix, pivotRows-1, "priceDistance")
                distanceMA = matrixGet(pivotMatrix, pivotRows-1, "distanceMA")
                lastMoveStrength = (lastPriceDistance * 100) / distanceMA
                lastPercentInRange = matrixGet(pivotMatrix, pivotRows-1, "percentInRange")
                trend = matrixGet(pivotMatrix, pivotRows-1, "trend")
                trendCount = matrixGet(pivotMatrix, pivotRows-1, "trendCount")
                currPriceDistance = math.abs(pivotPrice - close)
                currMoveStrength = (currPriceDistance * 100) / distanceMA
                currPercentInRange = currPriceDistance * 100 / lastPriceDistance

                matrix.add_row(dataMatrix, matrix.rows(dataMatrix), array.from(
                   getTimeframeEnglish(timeframe), // Timeframe
                   trendToString(trend), // in Trend
                   str.tostring(trendCount + 1), // # of moves in trend direction
                   (isHigher ? "Higher " : "Lower ") + (pivotType == 1 ? "High" : "Low"), // Set a 
                   str.tostring(pivotPrice, format.mintick), // at price
                   "NA", // getScout(trend, isHigher, pivotType), // Currently scouting
                   str.tostring(distanceMA, format.mintick), // Avg of moves in this direction
                   str.tostring(lastPriceDistance, format.mintick), // Last move was this $ there
                   str.tostring(lastMoveStrength, format.percent), // last move was this % there
                   str.tostring(lastPercentInRange, format.percent), // Fib % of last move
                   str.tostring(currPriceDistance, format.mintick), // Currently this $ there
                   str.tostring(lastMoveStrength, format.percent), // Currently this % there
                   str.tostring(lastPercentInRange, format.percent) // Fib % of current move
                   ))

                matrix.add_row(colorMatrix, matrix.rows(colorMatrix), array.new_color(columnCount, trendToColor(trend)))

        if matrix.rows(dataMatrix) > 1
            PrivateTable.fromMatrix(dataMatrix, colorMatrix, position=position.bottom_right, borderWidth=1)
        
drawScoutLabel() =>
    if (barstate.islast)
        trendArray = array.new_int()
        isBullish = -1
        friendlyMessage = string(na)
        scoutMessage = string(na)
        notes = string(na)
        timeframe = string(na)
        pivotType = float(na)
        pivotPrice = float(na)
        pivotTime = float(na)
        lastPivotPrice = float(na)
        lastPivotTime = float(na)
        pivotHigh = float(na)
        pivotLow = float(na)
        pivotHighTime = float(na)
        pivotLowTime = float(na)

        // Loop through each matrix gathering data you need for the analysis
        ancestryMatrix = matrix.new<float>()
        ancestryCount = 0
        for i = array.size(timeframeArray) - 1 to 0
            timeframe := array.get(timeframeArray, i)
            pivotMatrix = getMatrixByTimeframe(timeframe)
            pivotRows = matrix.rows(pivotMatrix)
            if (pivotRows > 1)
                trend = matrixGet(pivotMatrix, pivotRows-1, "trend")
                array.push(trendArray, math.round(trend))
                isBullish := getBullish(trendArray)
                pivotType := matrixGet(pivotMatrix, pivotRows-1, "pivotType")
                pivotPrice := matrixGet(pivotMatrix, pivotRows-1, "pivotPrice")
                pivotTime := matrixGetPivotTime(pivotMatrix, pivotRows-1, timeframe)
                lastPivotPrice := matrixGet(pivotMatrix, pivotRows-2, "pivotPrice")
                lastPivotTime := matrixGetPivotTime(pivotMatrix, pivotRows-2, timeframe)
                pivotHigh := pivotType == 1 ? pivotPrice : lastPivotPrice
                pivotLow := pivotType == 0 ? pivotPrice : lastPivotPrice
                pivotHighTime := pivotType == 1 ? pivotTime : lastPivotTime
                pivotLowTime := pivotType == 0 ? pivotTime : lastPivotTime
                matrix.add_row(ancestryMatrix, matrix.rows(ancestryMatrix), array.from(i, isBullish, pivotHigh, pivotLow, pivotHighTime, pivotLowTime))
                ancestryCount += 1

        if ancestryCount > 2
            parentIndex = ancestryCount - 2
            parentTF = array.get(timeframeArray, math.round(matrix.get(ancestryMatrix, parentIndex, 0)))
            parentBullish = matrix.get(ancestryMatrix, parentIndex, 1)
            parentHigh = matrix.get(ancestryMatrix, parentIndex, 2)
            parentLow = matrix.get(ancestryMatrix, parentIndex, 3)
            parentHighTime = matrix.get(ancestryMatrix, parentIndex, 4)
            parentLowTime = matrix.get(ancestryMatrix, parentIndex, 5)
            grandParentIndex = ancestryCount - 3
            grandParentTF = array.get(timeframeArray, math.round(matrix.get(ancestryMatrix, grandParentIndex, 0)))
            grandParentBullish = matrix.get(ancestryMatrix, grandParentIndex, 1)
            grandParentHigh = matrix.get(ancestryMatrix, grandParentIndex, 2)
            grandParentLow = matrix.get(ancestryMatrix, grandParentIndex, 3)
            grandParentHighTime = matrix.get(ancestryMatrix, grandParentIndex, 4)
            grandParentLowTime = matrix.get(ancestryMatrix, grandParentIndex, 5)

            labelTime = float(na)
            labelPrice = float(na)
            labelHigh = grandParentBullish == 0
            labelTimeframe = string(na)
            
            // Perform decision tree analysis
            if grandParentBullish == 1 
                labelHigh := false
                if parentBullish == 1
                    if isBullish == 1
                        labelTime := pivotLowTime
                        labelPrice := pivotLow
                        labelTimeframe := getTimeframeEnglish(timeframe)
                        friendlyMessage := "Full steam ahead, stay with trend"
                        scoutMessage := "Scout {0} Higher Low above {1,number,#.##} support"
                        notes := str.format("First red flag is loss of {0} Higher Lows", getTimeframeEnglish(parentTF))
                    else if isBullish == 0
                        labelTime := parentLowTime
                        labelPrice := parentLow
                        labelTimeframe := getTimeframeEnglish(parentTF)
                        scoutMessage := "Scout {0} Higher Low above {1,number,#.##} support"
                        notes := str.format("Potentially bottom fish support above {0,number,#.##}", parentLow)
                else if parentBullish == 0
                    labelTime := grandParentLowTime
                    labelPrice := grandParentLow
                    labelTimeframe := getTimeframeEnglish(grandParentTF)
                    scoutMessage := "Scout {0} Higher Low above {1,number,#.##} support"
            else if grandParentBullish == 0
                if parentBullish == 1
                    labelTime := grandParentHighTime
                    labelPrice := grandParentHigh
                    labelTimeframe := getTimeframeEnglish(grandParentTF)
                    scoutMessage := "Scout {0} Lower High below {1,number,#.##} resistance"
                    notes := str.format("Identify resistance criteria needed to change {0} trend bullish", labelTimeframe)
                else if parentBullish == 0
                    if isBullish == 1
                        labelTime := parentHighTime
                        labelPrice := parentHigh
                        labelTimeframe := getTimeframeEnglish(parentTF)
                        scoutMessage := "Scout {0} Lower High below {1,number,#.##} resistance"
                        notes := str.format("Look for {0} support break entry or topfish resistance at {1,number,#.##}", labelTimeframe, labelPrice)
                    else if isBullish == 0
                        labelTime := parentHighTime
                        labelPrice := parentHigh
                        labelTimeframe := getTimeframeEnglish(parentTF)
                        friendlyMessage := "Look out below!"
                        scoutMessage := "Scout {0} Lower High below {1,number,#.##} resistance"
                        notes := str.format("First red flag is loss of {0} Lower Highs", labelTimeframe)
            
            messageArray = array.new_string()
            if not na(friendlyMessage)
                array.push(messageArray, friendlyMessage)

            array.push(messageArray, str.format(scoutMessage, labelTimeframe, labelPrice))
            if not na(notes)
                array.push(messageArray, notes)

            scoutColor = labelHigh ? bearishColor : bullishColor
            scoutLine = line.new(
               x1=math.round(labelTime),
               x2=time[0], 
               y1=labelPrice,
               y2=labelPrice,
               color=scoutColor,
               xloc=xloc.bar_time,
               extend=extend.right,
               width=2
               )
            scoutLabel = label.new(
               x=time[0],
               y=labelPrice,
               text=array.join(messageArray, "\n"),
               size=size.small,
               xloc=xloc.bar_time,
               color=scoutColor,
               textcolor=color.white,
               textalign=text.align_left,
               style=(labelHigh == 1 ? label.style_label_lower_left : label.style_label_upper_left)
               )
            array.push(labelArray, scoutLabel)

tfIndex = array.indexof(timeframeArray, timeframe.period)
if (tfIndex >= 0)
    // Cleanup first (in case we are loading real-time data)
    cleanup()

    timeframeCount = array.size(timeframeArray)
    start = tfIndex
    end = timeframeCount - 1
    colors = array.from(color.blue, color.orange, color.red, color.black)
    x = 0
    maxLines = 24
    for i = start to end
        timeframe = array.get(timeframeArray, i)
        definePivotsByTimeframe(timeframe)
        if x < 3
            pColor = array.get(colors, x)
            drawPivotLines(timeframe, pColor, width=x+1, maxLines=maxLines)
            drawPivotAreas(timeframe, pColor, maxAreas = math.round(maxLines/2))
            drawFinalLabel(timeframe)
            // if (i == 2)
            //     drawPivotLabels(timeframe)
            maxLines := maxLines / 2
            x += 1
    
    // drawSummaryTable()
    drawScoutLabel() 

// if (barstate.islast and array.size(pDebug) > 0)
//     PrivateTable.fromArray(pDebug, transposeTable = true, position = position.bottom_left)

// ISSUE: 
// BA nov 3 @ 2pm
// 1h chart
// daily lower high is set at 150.14 from a few days ago, but the current price is already above that, which negates  the scout message
// Since this never set a lower low, I think that this just means we should still be looking for a daily lower high below the 173 resistance from the last high.
